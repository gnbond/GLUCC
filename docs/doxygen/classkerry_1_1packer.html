<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLUCC: kerry::packer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GLUCC<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kerry</b></li><li class="navelem"><a class="el" href="classkerry_1_1packer.html">packer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkerry_1_1packer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kerry::packer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Pack data into a binary protocol packet in a C++ manner.  
 <a href="classkerry_1_1packer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="packer_8hpp_source.html">packer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard container member types</div></td></tr>
<tr class="memitem:ac1e010d663eafd3b5e245afef8b5a43f"><td class="memItemLeft" align="right" valign="top"><a id="ac1e010d663eafd3b5e245afef8b5a43f" name="ac1e010d663eafd3b5e245afef8b5a43f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Vector::value_type</td></tr>
<tr class="separator:ac1e010d663eafd3b5e245afef8b5a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367aa0d38d2b613cda3dcee265f864e9"><td class="memItemLeft" align="right" valign="top"><a id="a367aa0d38d2b613cda3dcee265f864e9" name="a367aa0d38d2b613cda3dcee265f864e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = Vector::const_pointer</td></tr>
<tr class="separator:a367aa0d38d2b613cda3dcee265f864e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca749e3c96e1665a107f453218586a2"><td class="memItemLeft" align="right" valign="top"><a id="a0ca749e3c96e1665a107f453218586a2" name="a0ca749e3c96e1665a107f453218586a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = pointer</td></tr>
<tr class="separator:a0ca749e3c96e1665a107f453218586a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab84f6664323ea38cbaae28053bb245b"><td class="memItemLeft" align="right" valign="top"><a id="aab84f6664323ea38cbaae28053bb245b" name="aab84f6664323ea38cbaae28053bb245b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = Vector::const_reference</td></tr>
<tr class="separator:aab84f6664323ea38cbaae28053bb245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a274468bc1882dea126e978c4d75fc3"><td class="memItemLeft" align="right" valign="top"><a id="a9a274468bc1882dea126e978c4d75fc3" name="a9a274468bc1882dea126e978c4d75fc3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = reference</td></tr>
<tr class="separator:a9a274468bc1882dea126e978c4d75fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac8f1dc30ff0fc8f7a3f431d4c034f49e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a> ()=default</td></tr>
<tr class="memdesc:ac8f1dc30ff0fc8f7a3f431d4c034f49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new packer object with variable size.  <br /></td></tr>
<tr class="separator:ac8f1dc30ff0fc8f7a3f431d4c034f49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2710cb710ffcedeae61663d0ec58782"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ab2710cb710ffcedeae61663d0ec58782">packer</a> (std::size_t <a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>)</td></tr>
<tr class="memdesc:ab2710cb710ffcedeae61663d0ec58782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new packer object with a known packet size.  <br /></td></tr>
<tr class="separator:ab2710cb710ffcedeae61663d0ec58782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7779ed00875ecbf7625c0e9371fb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a4d7779ed00875ecbf7625c0e9371fb35">reserve</a> (std::size_t <a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>)</td></tr>
<tr class="memdesc:a4d7779ed00875ecbf7625c0e9371fb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for size bytes.  <br /></td></tr>
<tr class="separator:a4d7779ed00875ecbf7625c0e9371fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbaeb98668999d7a2cb62e4261ac02b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a> () const</td></tr>
<tr class="memdesc:a2fbaeb98668999d7a2cb62e4261ac02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current size of the packed data, in bytes.  <br /></td></tr>
<tr class="separator:a2fbaeb98668999d7a2cb62e4261ac02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd10526d48b5341c0d6f02355b576ee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">data</a> () const</td></tr>
<tr class="memdesc:abcd10526d48b5341c0d6f02355b576ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the constructed packet.  <br /></td></tr>
<tr class="separator:abcd10526d48b5341c0d6f02355b576ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6b4d0d86b4632ea2bc642110d5346b"><td class="memItemLeft" align="right" valign="top"><a id="a0e6b4d0d86b4632ea2bc642110d5346b" name="a0e6b4d0d86b4632ea2bc642110d5346b"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const</td></tr>
<tr class="separator:a0e6b4d0d86b4632ea2bc642110d5346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c320d4173497caa9549a46ad2597bee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a7c320d4173497caa9549a46ad2597bee">target_size</a> () const</td></tr>
<tr class="memdesc:a7c320d4173497caa9549a46ad2597bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target size for this packer.  <br /></td></tr>
<tr class="separator:a7c320d4173497caa9549a46ad2597bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a88f64e85f8580b5777cc8fa7263273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a6a88f64e85f8580b5777cc8fa7263273">clear</a> ()</td></tr>
<tr class="memdesc:a6a88f64e85f8580b5777cc8fa7263273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the packer for re-use.  <br /></td></tr>
<tr class="separator:a6a88f64e85f8580b5777cc8fa7263273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894fd18ebe651fdf8f6a7213860af7e"><td class="memItemLeft" align="right" valign="top"><a id="ae894fd18ebe651fdf8f6a7213860af7e" name="ae894fd18ebe651fdf8f6a7213860af7e"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::byte val)</td></tr>
<tr class="separator:ae894fd18ebe651fdf8f6a7213860af7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156481c0a03d69ab710d4c6dbcb4f25"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:aa156481c0a03d69ab710d4c6dbcb4f25"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#abd5356af8d23f000fbf26f12e742ffae">details::byte_integral</a>&lt; B &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#aa156481c0a03d69ab710d4c6dbcb4f25">operator&lt;&lt;</a> (B b)</td></tr>
<tr class="memdesc:aa156481c0a03d69ab710d4c6dbcb4f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a 1-byte integral type.  <br /></td></tr>
<tr class="separator:aa156481c0a03d69ab710d4c6dbcb4f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ae6fed85111b3d6f4c25f6c2dcd72dc20">operator&lt;&lt;</a> (const std::byte(&amp;b)[N])</td></tr>
<tr class="memdesc:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently insert a C-style array of std::byte.  <br /></td></tr>
<tr class="separator:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf32e58849ee41b24719fb79761d2a68"><td class="memTemplParams" colspan="2">template&lt;typename B , std::size_t N&gt; </td></tr>
<tr class="memitem:acf32e58849ee41b24719fb79761d2a68"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#abd5356af8d23f000fbf26f12e742ffae">details::byte_integral</a>&lt; B &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#acf32e58849ee41b24719fb79761d2a68">operator&lt;&lt;</a> (const B(&amp;b)[N])</td></tr>
<tr class="memdesc:acf32e58849ee41b24719fb79761d2a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently insert a C-style array of 1-byte integral types.  <br /></td></tr>
<tr class="separator:acf32e58849ee41b24719fb79761d2a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754d241bc64c6d0b514ab08421b6d3f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9754d241bc64c6d0b514ab08421b6d3f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a7aa8ec4a2befbe809c2b3c5ca566e21f">details::multibyte_packable</a>&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a9754d241bc64c6d0b514ab08421b6d3f">operator&lt;&lt;</a> (const T(&amp;b)[N])</td></tr>
<tr class="memdesc:a9754d241bc64c6d0b514ab08421b6d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a fixed-size C-style array of packable types.  <br /></td></tr>
<tr class="separator:a9754d241bc64c6d0b514ab08421b6d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff68874b12f89c157ef035ade186b128"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff68874b12f89c157ef035ade186b128"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a0d4ab4b9144943bc5c21476c4be1e6e9">details::packable</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#aff68874b12f89c157ef035ade186b128">push_back</a> (const T &amp;val)</td></tr>
<tr class="memdesc:aff68874b12f89c157ef035ade186b128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push any insertable type to the end of the packet.  <br /></td></tr>
<tr class="separator:aff68874b12f89c157ef035ade186b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709aa911a043bff637878b41fd61b6bd"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a709aa911a043bff637878b41fd61b6bd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a333952006ce717c4cebb63070dfcf9b8">details::byte_packable</a>&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a709aa911a043bff637878b41fd61b6bd">operator&lt;&lt;</a> (const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a709aa911a043bff637878b41fd61b6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a std::array of single-byte packable data.  <br /></td></tr>
<tr class="separator:a709aa911a043bff637878b41fd61b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01ea9ccc212e0fed217ce90e7d88f5c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab01ea9ccc212e0fed217ce90e7d88f5c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a7aa8ec4a2befbe809c2b3c5ca566e21f">details::multibyte_packable</a>&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ab01ea9ccc212e0fed217ce90e7d88f5c">operator&lt;&lt;</a> (const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:ab01ea9ccc212e0fed217ce90e7d88f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a std::array of multi-byte packable data.  <br /></td></tr>
<tr class="separator:ab01ea9ccc212e0fed217ce90e7d88f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet data access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Packets can be treated as streams of <code>std::byte</code>, <code>char</code>, or <code>unsigned char</code> types. Packets can be also be accessed as a <code>void*</code>.</p>
<p>These functions allow implicit conversion to the required type. Like the <code><a class="el" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee" title="Return a pointer to the constructed packet.">data()</a></code> member, they will throw <code><a class="el" href="structkerry_1_1size__error.html" title="Throw this error when added data exceeds pre-defined size.">size_error</a></code> for packers constructed with a target size, if the packed data is not exactly the right length.</p>
<p>Beware dangling pointers if the packer is destroyed or if more data is added.</p>
<p>Typical use might be: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> send(<span class="keywordtype">int</span> sock, <span class="keywordtype">void</span>* <a class="code hl_function" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">data</a>, <span class="keywordtype">size_t</span> len);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code hl_class" href="classkerry_1_1packer.html">packer</a> p{20};</div>
<div class="line"><span class="comment">// Insert exactly 20 bytes of data into p</span></div>
<div class="line"><span class="keywordflow">if</span> (send(sock, p, p.size()) &lt; 0) { handle error; }</div>
<div class="ttc" id="aclasskerry_1_1packer_html"><div class="ttname"><a href="classkerry_1_1packer.html">kerry::packer</a></div><div class="ttdoc">Pack data into a binary protocol packet in a C++ manner.</div><div class="ttdef"><b>Definition:</b> packer.hpp:158</div></div>
<div class="ttc" id="aclasskerry_1_1packer_html_abcd10526d48b5341c0d6f02355b576ee"><div class="ttname"><a href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">kerry::packer::data</a></div><div class="ttdeci">auto data() const</div><div class="ttdoc">Return a pointer to the constructed packet.</div><div class="ttdef"><b>Definition:</b> packer.hpp:218</div></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:ac6d71eb5a366865cd77486f5d82508bb"><td class="memItemLeft" align="right" valign="top"><a id="ac6d71eb5a366865cd77486f5d82508bb" name="ac6d71eb5a366865cd77486f5d82508bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const void *</b> ()</td></tr>
<tr class="separator:ac6d71eb5a366865cd77486f5d82508bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab23ab7c7d0788daa3fd35c0778b1f"><td class="memItemLeft" align="right" valign="top"><a id="af0ab23ab7c7d0788daa3fd35c0778b1f" name="af0ab23ab7c7d0788daa3fd35c0778b1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const std::byte *</b> ()</td></tr>
<tr class="separator:af0ab23ab7c7d0788daa3fd35c0778b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8b6203d8c300ad100a86793567daaa"><td class="memItemLeft" align="right" valign="top"><a id="a7f8b6203d8c300ad100a86793567daaa" name="a7f8b6203d8c300ad100a86793567daaa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const char *</b> ()</td></tr>
<tr class="separator:a7f8b6203d8c300ad100a86793567daaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745bc6a4030f395195f5166f98f0f4d9"><td class="memItemLeft" align="right" valign="top"><a id="a745bc6a4030f395195f5166f98f0f4d9" name="a745bc6a4030f395195f5166f98f0f4d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const unsigned char *</b> ()</td></tr>
<tr class="separator:a745bc6a4030f395195f5166f98f0f4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Iterators are provided to access the data. Updating packet contents via iterators is not supported. </p>
</div></td></tr>
<tr class="memitem:abc5c250612d08193ab9daeec0782b92e"><td class="memItemLeft" align="right" valign="top"><a id="abc5c250612d08193ab9daeec0782b92e" name="abc5c250612d08193ab9daeec0782b92e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:abc5c250612d08193ab9daeec0782b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42f0905fbf04e0fd0f2d3260c95b2a1"><td class="memItemLeft" align="right" valign="top"><a id="ac42f0905fbf04e0fd0f2d3260c95b2a1" name="ac42f0905fbf04e0fd0f2d3260c95b2a1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:ac42f0905fbf04e0fd0f2d3260c95b2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Integral Types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Inserters for 2 and 4-byte integral types.</p>
<p>These are converted to network byte order. </p>
</div></td></tr>
<tr class="memitem:af43842a19088165297210ee0b554e605"><td class="memItemLeft" align="right" valign="top"><a id="af43842a19088165297210ee0b554e605" name="af43842a19088165297210ee0b554e605"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::int16_t val)</td></tr>
<tr class="separator:af43842a19088165297210ee0b554e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af747d46f8954a38451b197803e1d6016"><td class="memItemLeft" align="right" valign="top"><a id="af747d46f8954a38451b197803e1d6016" name="af747d46f8954a38451b197803e1d6016"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::uint16_t val)</td></tr>
<tr class="separator:af747d46f8954a38451b197803e1d6016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062c9747a00a04693eb0d8442b867c1"><td class="memItemLeft" align="right" valign="top"><a id="a7062c9747a00a04693eb0d8442b867c1" name="a7062c9747a00a04693eb0d8442b867c1"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::int32_t val)</td></tr>
<tr class="separator:a7062c9747a00a04693eb0d8442b867c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91573e8a4d5c92b55a5906a25b3770f6"><td class="memItemLeft" align="right" valign="top"><a id="a91573e8a4d5c92b55a5906a25b3770f6" name="a91573e8a4d5c92b55a5906a25b3770f6"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::uint32_t val)</td></tr>
<tr class="separator:a91573e8a4d5c92b55a5906a25b3770f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pack data into a binary protocol packet in a C++ manner. </p>
<p>Dealing with binary protocol packets hasn't really changed in 40 years - it's still usually C code, and usually a horrible mix of type punning, malloc()'d memory, unsafe pointer casts, and calls to <code>htonl()</code> and <code>memcpy()</code>, all written with silent prayers that the new 64-bit compiler version won't add invisible padding bytes to your structs.</p>
<p>Then you run a static analyzer over your code, and have to silence hundreds of warnings about all those unsafe 40-year-old coding practices. And heaven help you if you also need to meet MISRA or similar high-integrity software standards.</p>
<p>There's gotta be a better way. A C++ way.</p>
<p>Well, now there is.</p>
<p><a class="el" href="classkerry_1_1packer.html" title="Pack data into a binary protocol packet in a C++ manner.">kerry::packer</a> uses an API inspired by C++ iostreams inserters that is extensible, type-safe and bounds-safe. It wraps <code>std::vector&lt;std::byte&gt;</code> to store the generated packet data and avoid any memory leaks or bounds errors. It provides inserters for 1/2/4-byte integral types (converting to network byte order as required). It provides inserters for fixed-size (C-style) arrays and std::arrays of supported types, including arrays of custom types with user-written inserters. It hides all the network byte order conversions, the reinterpret_cast&lt;&gt;s and the memory copies needed to take a C++ object and turn it into a byte stream.</p>
<p>The packer can be created in two modes. The default-constructed packer is suitable for variable-sized network packets, leaving the calling code to be responsible for checking the size of the generated packet matches expectation, if that is required. A packer created with a size argument is suitable for fixed-size network packets, and the packer will check that the generated packet is exactly that many bytes (by throwing an exception when the data is extracted if the size is not exactly correct).</p>
<p>Another annoyance in network programming is the inconsistencies with the types used to store binary packets and the standard functions used to manipulate those packets. Old code uses <code>char *</code> or sometimes <code>unsigned char*</code>. Slightly less old code uses <code>void *</code>. The packer uses std::byte as the native type (this use-case seems to be the main intention of the std::byte type) but allows implicit conversions to <code>void*</code>, <code>char*</code> and <code>unsigned char*</code>. So the following code is typical: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classkerry_1_1packer.html">packer</a> p;</div>
<div class="line"><span class="keywordtype">int</span> sock = socket(...);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">p &lt;&lt; some &lt;&lt; <a class="code hl_function" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">data</a>;</div>
<div class="line">send(sock, p, p.<a class="code hl_function" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>(), 0)</div>
<div class="ttc" id="aclasskerry_1_1packer_html_a2fbaeb98668999d7a2cb62e4261ac02b"><div class="ttname"><a href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">kerry::packer::size</a></div><div class="ttdeci">auto size() const</div><div class="ttdoc">Return the current size of the packed data, in bytes.</div><div class="ttdef"><b>Definition:</b> packer.hpp:206</div></div>
</div><!-- fragment --><p>A somewhat contrived example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>item { uint8_t tag; uint16_t value; }</div>
<div class="line"><span class="keyword">struct </span>item_packet { uint8_t count; item items[4]; uint32_t checksum; }</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; operator&lt;&lt;(<a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; p, <span class="keyword">const</span> item&amp; i) {</div>
<div class="line">    <span class="keywordflow">return</span> p &lt;&lt; i.count &lt;&lt; i.value;</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; operator&lt;&lt;(<a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; p, <span class="keyword">const</span> item_packet&amp; ip) {</div>
<div class="line">    <span class="keywordflow">return</span> p &lt;&lt; ip.count &lt;&lt; ip.items &lt;&lt; ip.checksum;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">pack_and_send(<span class="keywordtype">int</span> sock, <span class="keyword">const</span> item_packet&amp; ip) {</div>
<div class="line">    <a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a> p{17};</div>
<div class="line">    p &lt;&lt; ip;</div>
<div class="line">    <span class="keywordflow">if</span> (send(sock, p, p.<a class="code hl_function" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>(), 0) &lt; 0) {</div>
<div class="line">        <span class="comment">// handle error</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasskerry_1_1packer_html_ac8f1dc30ff0fc8f7a3f431d4c034f49e"><div class="ttname"><a href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">kerry::packer::packer</a></div><div class="ttdeci">packer()=default</div><div class="ttdoc">Construct a new packer object with variable size.</div></div>
</div><!-- fragment --><p>What's with the namespace? This is a little pun that should raise a smile from anyone familiar with the last 40 years of Australian media or political affairs. Or the history of cricket in the late 20th century.</p>
<p>TBD:</p><ul>
<li>member documentation</li>
<li>example usage</li>
<li>consider binary blobs. make copy() public?</li>
<li>support other containers of packable types? (std::vector? iterators? ) </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac8f1dc30ff0fc8f7a3f431d4c034f49e" name="ac8f1dc30ff0fc8f7a3f431d4c034f49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f1dc30ff0fc8f7a3f431d4c034f49e">&#9670;&#160;</a></span>packer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kerry::packer::packer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new packer object with variable size. </p>

</div>
</div>
<a id="ab2710cb710ffcedeae61663d0ec58782" name="ab2710cb710ffcedeae61663d0ec58782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2710cb710ffcedeae61663d0ec58782">&#9670;&#160;</a></span>packer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kerry::packer::packer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new packer object with a known packet size. </p>
<p><a class="el" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee" title="Return a pointer to the constructed packet.">data()</a> will throw <a class="el" href="structkerry_1_1size__error.html" title="Throw this error when added data exceeds pre-defined size.">size_error</a> if there are not exactly this many bytes of data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>packet size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a88f64e85f8580b5777cc8fa7263273" name="a6a88f64e85f8580b5777cc8fa7263273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a88f64e85f8580b5777cc8fa7263273">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kerry::packer::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the packer for re-use. </p>
<p>Target size is not updated but <a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b" title="Return the current size of the packed data, in bytes.">size()</a> is set to zero and existing packet data is lost. </p>

</div>
</div>
<a id="abcd10526d48b5341c0d6f02355b576ee" name="abcd10526d48b5341c0d6f02355b576ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd10526d48b5341c0d6f02355b576ee">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kerry::packer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the constructed packet. </p>
<p>This will throw <a class="el" href="structkerry_1_1size__error.html" title="Throw this error when added data exceeds pre-defined size.">size_error</a> if the packer was created with a target size and there are not exactly that many bytes in the packet.</p>
<p>Beware dangling pointers if the packer is destroyed or if more data is added.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::byte* </dd></dl>

</div>
</div>
<a id="aa156481c0a03d69ab710d4c6dbcb4f25" name="aa156481c0a03d69ab710d4c6dbcb4f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa156481c0a03d69ab710d4c6dbcb4f25">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#abd5356af8d23f000fbf26f12e742ffae">details::byte_integral</a>&lt; B &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a 1-byte integral type. </p>
<p>This template works for all integral 1-byte types, including bool but does not allow larger integral types to accidentally use it</p>
<p>1-byte values do not need network byte order conversion</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>A 1-byte integral type (char, unsigned char, signed char, bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The value of type B to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="acf32e58849ee41b24719fb79761d2a68" name="acf32e58849ee41b24719fb79761d2a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf32e58849ee41b24719fb79761d2a68">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#abd5356af8d23f000fbf26f12e742ffae">details::byte_integral</a>&lt; B &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const B(&amp;)&#160;</td>
          <td class="paramname"><em>b</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently insert a C-style array of 1-byte integral types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>a 1-byte integral type </td></tr>
    <tr><td class="paramname">N</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="a709aa911a043bff637878b41fd61b6bd" name="a709aa911a043bff637878b41fd61b6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709aa911a043bff637878b41fd61b6bd">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a333952006ce717c4cebb63070dfcf9b8">details::byte_packable</a>&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a std::array of single-byte packable data. </p>
<p>This uses copy() to pack the array efficiently</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to pack </td></tr>
    <tr><td class="paramname">N</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="ab01ea9ccc212e0fed217ce90e7d88f5c" name="ab01ea9ccc212e0fed217ce90e7d88f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01ea9ccc212e0fed217ce90e7d88f5c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a7aa8ec4a2befbe809c2b3c5ca566e21f">details::multibyte_packable</a>&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a std::array of multi-byte packable data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to pack </td></tr>
    <tr><td class="paramname">N</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="ae6fed85111b3d6f4c25f6c2dcd72dc20" name="ae6fed85111b3d6f4c25f6c2dcd72dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fed85111b3d6f4c25f6c2dcd72dc20">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkerry_1_1packer.html">packer</a> &amp; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::byte(&amp;)&#160;</td>
          <td class="paramname"><em>b</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently insert a C-style array of std::byte. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="a9754d241bc64c6d0b514ab08421b6d3f" name="a9754d241bc64c6d0b514ab08421b6d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754d241bc64c6d0b514ab08421b6d3f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a7aa8ec4a2befbe809c2b3c5ca566e21f">details::multibyte_packable</a>&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>b</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a fixed-size C-style array of packable types. </p>
<p>Allow C-style arrays of any non-byte-sized type for which we already have an inserter, including custom types with custom inserters. C-style arrays of byte-sized types integral are handled above using a direct call to copy() for efficiency</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects to be inserted </td></tr>
    <tr><td class="paramname">N</td><td>The number of objects to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="aff68874b12f89c157ef035ade186b128" name="aff68874b12f89c157ef035ade186b128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff68874b12f89c157ef035ade186b128">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="packer_8hpp.html#a0d4ab4b9144943bc5c21476c4be1e6e9">details::packable</a>&lt; T &gt; &gt; kerry::packer::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push any insertable type to the end of the packet. </p>
<p>Alas, back_insert_iterator&lt;&gt; can only insert Container::value_type (aka std::byte) so this is not as useful as it might be</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>an insertable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to push into the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d7779ed00875ecbf7625c0e9371fb35" name="a4d7779ed00875ecbf7625c0e9371fb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7779ed00875ecbf7625c0e9371fb35">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kerry::packer::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve space for size bytes. </p>
<p>This is a no-op if the packer was created with a target size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fbaeb98668999d7a2cb62e4261ac02b" name="a2fbaeb98668999d7a2cb62e4261ac02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbaeb98668999d7a2cb62e4261ac02b">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kerry::packer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current size of the packed data, in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>

</div>
</div>
<a id="a7c320d4173497caa9549a46ad2597bee" name="a7c320d4173497caa9549a46ad2597bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c320d4173497caa9549a46ad2597bee">&#9670;&#160;</a></span>target_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kerry::packer::target_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The target size for this packer. </p>
<p>Returns 0 if this packer was not created with a target size</p>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="packer_8hpp_source.html">packer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
