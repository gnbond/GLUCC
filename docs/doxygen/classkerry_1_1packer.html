<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLUCC: kerry::packer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GLUCC<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kerry</b></li><li class="navelem"><a class="el" href="classkerry_1_1packer.html">packer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkerry_1_1packer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kerry::packer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Pack data into a network packet in a C++ manner.  
 <a href="classkerry_1_1packer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="packer_8hpp_source.html">packer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac8f1dc30ff0fc8f7a3f431d4c034f49e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a> ()=default</td></tr>
<tr class="memdesc:ac8f1dc30ff0fc8f7a3f431d4c034f49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new packer object with variable size.  <br /></td></tr>
<tr class="separator:ac8f1dc30ff0fc8f7a3f431d4c034f49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2710cb710ffcedeae61663d0ec58782"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ab2710cb710ffcedeae61663d0ec58782">packer</a> (std::size_t <a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>)</td></tr>
<tr class="memdesc:ab2710cb710ffcedeae61663d0ec58782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new packer object with a known packet size.  <br /></td></tr>
<tr class="separator:ab2710cb710ffcedeae61663d0ec58782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7779ed00875ecbf7625c0e9371fb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a4d7779ed00875ecbf7625c0e9371fb35">reserve</a> (std::size_t <a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>)</td></tr>
<tr class="memdesc:a4d7779ed00875ecbf7625c0e9371fb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for size bytes.  <br /></td></tr>
<tr class="separator:a4d7779ed00875ecbf7625c0e9371fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbaeb98668999d7a2cb62e4261ac02b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a> () const</td></tr>
<tr class="memdesc:a2fbaeb98668999d7a2cb62e4261ac02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current size of the packed data, in bytes.  <br /></td></tr>
<tr class="separator:a2fbaeb98668999d7a2cb62e4261ac02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd10526d48b5341c0d6f02355b576ee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">data</a> () const</td></tr>
<tr class="memdesc:abcd10526d48b5341c0d6f02355b576ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the constructed packet.  <br /></td></tr>
<tr class="separator:abcd10526d48b5341c0d6f02355b576ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6b4d0d86b4632ea2bc642110d5346b"><td class="memItemLeft" align="right" valign="top"><a id="a0e6b4d0d86b4632ea2bc642110d5346b" name="a0e6b4d0d86b4632ea2bc642110d5346b"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const</td></tr>
<tr class="separator:a0e6b4d0d86b4632ea2bc642110d5346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c320d4173497caa9549a46ad2597bee"><td class="memItemLeft" align="right" valign="top"><a id="a7c320d4173497caa9549a46ad2597bee" name="a7c320d4173497caa9549a46ad2597bee"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>target_size</b> () const</td></tr>
<tr class="separator:a7c320d4173497caa9549a46ad2597bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5c250612d08193ab9daeec0782b92e"><td class="memItemLeft" align="right" valign="top"><a id="abc5c250612d08193ab9daeec0782b92e" name="abc5c250612d08193ab9daeec0782b92e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:abc5c250612d08193ab9daeec0782b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42f0905fbf04e0fd0f2d3260c95b2a1"><td class="memItemLeft" align="right" valign="top"><a id="ac42f0905fbf04e0fd0f2d3260c95b2a1" name="ac42f0905fbf04e0fd0f2d3260c95b2a1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:ac42f0905fbf04e0fd0f2d3260c95b2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a88f64e85f8580b5777cc8fa7263273"><td class="memItemLeft" align="right" valign="top"><a id="a6a88f64e85f8580b5777cc8fa7263273" name="a6a88f64e85f8580b5777cc8fa7263273"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a6a88f64e85f8580b5777cc8fa7263273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9e2fab7c02e71f4e48bada213f3824"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a7c9e2fab7c02e71f4e48bada213f3824"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a7c9e2fab7c02e71f4e48bada213f3824">operator==</a> (const C &amp;rhs)</td></tr>
<tr class="memdesc:a7c9e2fab7c02e71f4e48bada213f3824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the contents of the packet to a container.  <br /></td></tr>
<tr class="separator:a7c9e2fab7c02e71f4e48bada213f3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894fd18ebe651fdf8f6a7213860af7e"><td class="memItemLeft" align="right" valign="top"><a id="ae894fd18ebe651fdf8f6a7213860af7e" name="ae894fd18ebe651fdf8f6a7213860af7e"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::byte val)</td></tr>
<tr class="separator:ae894fd18ebe651fdf8f6a7213860af7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0621ea9bdad8c3e0e39f158c36e4e1b4"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a0621ea9bdad8c3e0e39f158c36e4e1b4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; B &gt; &amp;&amp;sizeof(B)==1, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#a0621ea9bdad8c3e0e39f158c36e4e1b4">operator&lt;&lt;</a> (B b)</td></tr>
<tr class="memdesc:a0621ea9bdad8c3e0e39f158c36e4e1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a 1-byte integral type.  <br /></td></tr>
<tr class="separator:a0621ea9bdad8c3e0e39f158c36e4e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ae6fed85111b3d6f4c25f6c2dcd72dc20">operator&lt;&lt;</a> (const std::byte(&amp;b)[N])</td></tr>
<tr class="memdesc:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently insert a C-style array of std::byte.  <br /></td></tr>
<tr class="separator:ae6fed85111b3d6f4c25f6c2dcd72dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55f4edac0d5755da213c7a9c21f5b77"><td class="memTemplParams" colspan="2">template&lt;typename B , std::size_t N&gt; </td></tr>
<tr class="memitem:ae55f4edac0d5755da213c7a9c21f5b77"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; B &gt; &amp;&amp;sizeof(B)==1, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#ae55f4edac0d5755da213c7a9c21f5b77">operator&lt;&lt;</a> (const B(&amp;b)[N])</td></tr>
<tr class="memdesc:ae55f4edac0d5755da213c7a9c21f5b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently insert a C-style array of 1-byte integral types.  <br /></td></tr>
<tr class="separator:ae55f4edac0d5755da213c7a9c21f5b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00b08397be3a6e72fd1bab31f73b106"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa00b08397be3a6e72fd1bab31f73b106"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; multibyte_packable&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkerry_1_1packer.html#aa00b08397be3a6e72fd1bab31f73b106">operator&lt;&lt;</a> (const T(&amp;b)[N])</td></tr>
<tr class="memdesc:aa00b08397be3a6e72fd1bab31f73b106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a fixed-size C-style array of packable types.  <br /></td></tr>
<tr class="separator:aa00b08397be3a6e72fd1bab31f73b106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet data access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Packet data acces</p>
<p>Packets can be treated as streams of <code>std::byte</code>, <code>char</code>, or <code>unsigned char</code> types. Packets can be also be accessed as a <code>void*</code>.</p>
<p>These functions allow implicit conversion to the required type. Like the <code><a class="el" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee" title="Return a pointer to the constructed packet.">data()</a></code> member, they will throw <code><a class="el" href="structkerry_1_1size__error.html" title="Throw this error when added data exceeds pre-defined size.">size_error</a></code> for packers constructed with a target size, if the packed data is not exactly the right length.</p>
<p>Typical use might be: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> send(<span class="keywordtype">int</span> sock, <span class="keywordtype">void</span>* <a class="code hl_function" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">data</a>, <span class="keywordtype">size_t</span> len);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code hl_class" href="classkerry_1_1packer.html">packer</a> p{20};</div>
<div class="line"><span class="comment">// Insert exactly 20 bytes of data into p</span></div>
<div class="line"><span class="keywordflow">if</span> (send(sock, p, p.size()) &lt; 0) { handle error; }</div>
<div class="ttc" id="aclasskerry_1_1packer_html"><div class="ttname"><a href="classkerry_1_1packer.html">kerry::packer</a></div><div class="ttdoc">Pack data into a network packet in a C++ manner.</div><div class="ttdef"><b>Definition:</b> packer.hpp:118</div></div>
<div class="ttc" id="aclasskerry_1_1packer_html_abcd10526d48b5341c0d6f02355b576ee"><div class="ttname"><a href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">kerry::packer::data</a></div><div class="ttdeci">auto data() const</div><div class="ttdoc">Return a pointer to the constructed packet.</div><div class="ttdef"><b>Definition:</b> packer.hpp:161</div></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:ac6d71eb5a366865cd77486f5d82508bb"><td class="memItemLeft" align="right" valign="top"><a id="ac6d71eb5a366865cd77486f5d82508bb" name="ac6d71eb5a366865cd77486f5d82508bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const void *</b> ()</td></tr>
<tr class="separator:ac6d71eb5a366865cd77486f5d82508bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab23ab7c7d0788daa3fd35c0778b1f"><td class="memItemLeft" align="right" valign="top"><a id="af0ab23ab7c7d0788daa3fd35c0778b1f" name="af0ab23ab7c7d0788daa3fd35c0778b1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const std::byte *</b> ()</td></tr>
<tr class="separator:af0ab23ab7c7d0788daa3fd35c0778b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8b6203d8c300ad100a86793567daaa"><td class="memItemLeft" align="right" valign="top"><a id="a7f8b6203d8c300ad100a86793567daaa" name="a7f8b6203d8c300ad100a86793567daaa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const char *</b> ()</td></tr>
<tr class="separator:a7f8b6203d8c300ad100a86793567daaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745bc6a4030f395195f5166f98f0f4d9"><td class="memItemLeft" align="right" valign="top"><a id="a745bc6a4030f395195f5166f98f0f4d9" name="a745bc6a4030f395195f5166f98f0f4d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const unsigned char *</b> ()</td></tr>
<tr class="separator:a745bc6a4030f395195f5166f98f0f4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Integral Types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Inserters for 2 and 4-byte integral types.</p>
<p>These are converted to network byte order. </p>
</div></td></tr>
<tr class="memitem:af43842a19088165297210ee0b554e605"><td class="memItemLeft" align="right" valign="top"><a id="af43842a19088165297210ee0b554e605" name="af43842a19088165297210ee0b554e605"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::int16_t val)</td></tr>
<tr class="separator:af43842a19088165297210ee0b554e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af747d46f8954a38451b197803e1d6016"><td class="memItemLeft" align="right" valign="top"><a id="af747d46f8954a38451b197803e1d6016" name="af747d46f8954a38451b197803e1d6016"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::uint16_t val)</td></tr>
<tr class="separator:af747d46f8954a38451b197803e1d6016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062c9747a00a04693eb0d8442b867c1"><td class="memItemLeft" align="right" valign="top"><a id="a7062c9747a00a04693eb0d8442b867c1" name="a7062c9747a00a04693eb0d8442b867c1"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::int32_t val)</td></tr>
<tr class="separator:a7062c9747a00a04693eb0d8442b867c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91573e8a4d5c92b55a5906a25b3770f6"><td class="memItemLeft" align="right" valign="top"><a id="a91573e8a4d5c92b55a5906a25b3770f6" name="a91573e8a4d5c92b55a5906a25b3770f6"></a>
<a class="el" href="classkerry_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::uint32_t val)</td></tr>
<tr class="separator:a91573e8a4d5c92b55a5906a25b3770f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pack data into a network packet in a C++ manner. </p>
<p>Dealing with binary protocol packets hasn't really changed in 40 years - it's still usually C code, and usually a horrible mix of type punning, unsafe pointer casts, and calls to <code>htonl()</code> and <code>memcpy()</code>, all written with silent prayers that the new 64-bit compiler version won't add invisible padding bytes to your structs.</p>
<p>Then you run a static analyzer over your code, and have to silence hundreds of warnings about all those unsafe 40-year-old coding practices.</p>
<p>There's gotta be a better way. A C++ way.</p>
<p>Well, now there is.</p>
<p><a class="el" href="classkerry_1_1packer.html" title="Pack data into a network packet in a C++ manner.">kerry::packer</a> uses an API inspired by C++ iostreams inserters that is extensible and type-safe. It wraps <code>std::vector&lt;std::byte&gt;</code> to store the generated packet data. It provides inserters for 1/2/4-byte integral types (converting to network byte order as required). It provides inserters for fixed-size (C-style) arrays of supported types, including arrays of custom types with user-written inserters.</p>
<p>The packer can be created in two modes. The default-constructed packer is suitable for variable-sized network packets, leaving the calling code to be responsible for checking the size of the generated packet matches expectation, if that is required. A packer created with a size argument is suitable for fixed-size network packets, and the packer will check that the generated packet is exactly that many bytes (by throwing an exception when the data is extracted if the size is not exactly correct).</p>
<p>Another annoyance is the inconsistencies with the types used to store binary packets and the standard functions used to manipulate those packets. The packer uses std::byte as the native type (this use-case seems to be the main intention of the std::byte type) but allows implicit conversions to <code>void*</code>, <code>char*</code> and <code>unsigned char*</code>. So the following code is typical: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classkerry_1_1packer.html">packer</a> p;</div>
<div class="line"><span class="keywordtype">int</span> sock = socket(...);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">p &lt;&lt; some &lt;&lt; <a class="code hl_function" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee">data</a>;</div>
<div class="line">send(sock, p, p.<a class="code hl_function" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>(), 0)</div>
<div class="ttc" id="aclasskerry_1_1packer_html_a2fbaeb98668999d7a2cb62e4261ac02b"><div class="ttname"><a href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">kerry::packer::size</a></div><div class="ttdeci">auto size() const</div><div class="ttdoc">Return the current size of the packed data, in bytes.</div><div class="ttdef"><b>Definition:</b> packer.hpp:152</div></div>
</div><!-- fragment --><p>A somewhat contrived example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>item { uint8_t tag; uint16_t value; }</div>
<div class="line"><span class="keyword">struct </span>item_packet { uint8_t count; item items[4]; uint32_t checksum; }</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; operator&lt;&lt;(<a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; p, <span class="keyword">const</span> item&amp; i) {</div>
<div class="line">    <span class="keywordflow">return</span> p &lt;&lt; i.count &lt;&lt; i.value;</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; operator&lt;&lt;(<a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a>&amp; p, <span class="keyword">const</span> item_packet&amp; ip) {</div>
<div class="line">    <span class="keywordflow">return</span> p &lt;&lt; ip.count &lt;&lt; ip.items &lt;&lt; ip.checksum;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">send(<span class="keywordtype">int</span> sock, <span class="keyword">const</span> item_packet&amp; ip) {</div>
<div class="line">    <a class="code hl_function" href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">packer</a> p{17};</div>
<div class="line">    p &lt;&lt; ip;</div>
<div class="line">    <span class="keywordflow">if</span> (send(sock, p, p.<a class="code hl_function" href="classkerry_1_1packer.html#a2fbaeb98668999d7a2cb62e4261ac02b">size</a>()) &lt; 0) {</div>
<div class="line">        <span class="comment">// handle error</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasskerry_1_1packer_html_ac8f1dc30ff0fc8f7a3f431d4c034f49e"><div class="ttname"><a href="classkerry_1_1packer.html#ac8f1dc30ff0fc8f7a3f431d4c034f49e">kerry::packer::packer</a></div><div class="ttdeci">packer()=default</div><div class="ttdoc">Construct a new packer object with variable size.</div></div>
</div><!-- fragment --><p> What's with the namespace? This is a little pun that should raise a smile from anyone familiar with the last 40 years of Australian media or political affairs. Or the history of cricket in the late 20th century.</p>
<p>TBD:</p><ul>
<li>member documentation</li>
<li>example usage</li>
<li>consider binary blobs. make copy() public?</li>
<li>support other containers of packable types? (std::array, std::vector? iterators? ) </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac8f1dc30ff0fc8f7a3f431d4c034f49e" name="ac8f1dc30ff0fc8f7a3f431d4c034f49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f1dc30ff0fc8f7a3f431d4c034f49e">&#9670;&#160;</a></span>packer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kerry::packer::packer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new packer object with variable size. </p>

</div>
</div>
<a id="ab2710cb710ffcedeae61663d0ec58782" name="ab2710cb710ffcedeae61663d0ec58782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2710cb710ffcedeae61663d0ec58782">&#9670;&#160;</a></span>packer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kerry::packer::packer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new packer object with a known packet size. </p>
<p><a class="el" href="classkerry_1_1packer.html#abcd10526d48b5341c0d6f02355b576ee" title="Return a pointer to the constructed packet.">data()</a> will throw <a class="el" href="structkerry_1_1size__error.html" title="Throw this error when added data exceeds pre-defined size.">size_error</a> if there are not exactly this many bytes of data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>packet size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abcd10526d48b5341c0d6f02355b576ee" name="abcd10526d48b5341c0d6f02355b576ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd10526d48b5341c0d6f02355b576ee">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kerry::packer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the constructed packet. </p>
<p>This will throw <a class="el" href="structkerry_1_1size__error.html" title="Throw this error when added data exceeds pre-defined size.">size_error</a> if the packer was created with a target size and there are not exactly that many bytes in the packet.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::byte* </dd></dl>

</div>
</div>
<a id="a0621ea9bdad8c3e0e39f158c36e4e1b4" name="a0621ea9bdad8c3e0e39f158c36e4e1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0621ea9bdad8c3e0e39f158c36e4e1b4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; B &gt; &amp;&amp;sizeof(B)==1, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a 1-byte integral type. </p>
<p>This template works for all integral 1-byte types, including bool but does not allow larger integral types to accidentally use it</p>
<p>1-byte values do not need network byte order conversion</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>A 1-byte integral type (char, unsigned char, signed char, bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The value of type B to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="ae55f4edac0d5755da213c7a9c21f5b77" name="ae55f4edac0d5755da213c7a9c21f5b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55f4edac0d5755da213c7a9c21f5b77">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; B &gt; &amp;&amp;sizeof(B)==1, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const B(&amp;)&#160;</td>
          <td class="paramname"><em>b</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently insert a C-style array of 1-byte integral types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>a 1-byte integral type </td></tr>
    <tr><td class="paramname">N</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="ae6fed85111b3d6f4c25f6c2dcd72dc20" name="ae6fed85111b3d6f4c25f6c2dcd72dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fed85111b3d6f4c25f6c2dcd72dc20">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkerry_1_1packer.html">packer</a> &amp; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::byte(&amp;)&#160;</td>
          <td class="paramname"><em>b</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently insert a C-style array of std::byte. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="aa00b08397be3a6e72fd1bab31f73b106" name="aa00b08397be3a6e72fd1bab31f73b106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00b08397be3a6e72fd1bab31f73b106">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; multibyte_packable&lt; T &gt;, <a class="el" href="classkerry_1_1packer.html">packer</a> &amp; &gt; kerry::packer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>b</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a fixed-size C-style array of packable types. </p>
<p>Allow C-style arrays of any non-byte-sized type for which we already have an inserter, including custom types with custom inserters. C-style arrays of byte-sized types integral are handled above using a direct call to copy() for efficiency</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects to be inserted </td></tr>
    <tr><td class="paramname">N</td><td>The number of objects to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packer&amp; </dd></dl>

</div>
</div>
<a id="a7c9e2fab7c02e71f4e48bada213f3824" name="a7c9e2fab7c02e71f4e48bada213f3824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9e2fab7c02e71f4e48bada213f3824">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kerry::packer::operator== </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the contents of the packet to a container. </p>
<p>This is mostly for the unit testing. The Catch2 expression-parsing types work much better if this is a member function not a free function in the unit test code.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>A container type of integral values convertable to std::byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The containter to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the packet contents match the container </dd>
<dd>
false if the packet contents do not match the container </dd></dl>

</div>
</div>
<a id="a4d7779ed00875ecbf7625c0e9371fb35" name="a4d7779ed00875ecbf7625c0e9371fb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7779ed00875ecbf7625c0e9371fb35">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kerry::packer::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve space for size bytes. </p>
<p>This is a no-op if the packer was created with a target size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fbaeb98668999d7a2cb62e4261ac02b" name="a2fbaeb98668999d7a2cb62e4261ac02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbaeb98668999d7a2cb62e4261ac02b">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kerry::packer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current size of the packed data, in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="packer_8hpp_source.html">packer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
